では、19.5節から説明し続けます。さっき、前田さんはETSの基本的な操作を紹介しました。19.5節から、もう一つデータを格納するモジュールDETSを紹介します。DETSは、メモリにデータを保存する代わりに、ハードディスクにデータを保存します。各DTESファイルは最大2GBまで可能です。使用する前にDETSファイルをopenする必要があります。そしてそれを使用した後、それはcloseすべきです。DETSファイルをcloseしないと、次回にこのファイルを使用するときに、システムは自動的にこのファイルを修復します。この修復処理は非常に時間がかかるため、プログラムを終了する前にDETSファイルをclose必要があります。

DETSファイルを開くときに、このファイルにグローバル名前を付ける必要があります。複数のプロセスがDETSファイルを同じ名前とオプションで開くと、すべてのプロセスがDETSファイルをcloseするまでDTESファイルは常にopen状態のままです。次に、例を使ってDETSファイルを操作する方法を示します。この例で、2つ関数を定義しました。関数filename2indexはファイル名を整数にマップします。関数index2filenameは整数をファイル名にマップします。

この例では、DETSテーブルを作成しました。このDETSテーブルには以下の3つ種類のタプルが格納されます。
{free, N}
このタプルは、整数Nはまだ使用されていないを表します。次回は、新しいファイルを整数にマップするときは、このファイルをNにマップします。
{FileNameBin, K}
このタプルは、ファイルFileNameBinが整数Kにマップされていることを示します。
{K, FileNameBin}
このタプルは、整数KがファイルFileNameBinにマップされていることを示します。

プログラムの効率を向上させるために、毎回新しいファイルFを整数Kにマップする時に、{F,K}と{K,F}の2つのタプルがDETSテーブルに追加されます。

では、ページ318のコードに行きます。
関数openの役割は、DETSファイルを開くことです。指定されたDETSファイルが存在しない場合、関数openは新しいDETSテーブルを作成し、このテーブルに{free, 1}というタプルを挿入します。関数openの４行目の記号?MODULEは、後続のコードに頻繁に表示されます。?MODULEは、Erlangによって定義されたマクロです。プログラムでは、?MODULEは現在のモジュールの名前として解釈されます。すなわち、lib_filenames_dets。プログラム内のDETSテーブル名の一意性を保証する必要があるため、現在のモジュールの名前をDETSテーブル名として使用します。

DETSテーブルを開くと、このテーブルにデータを挿入するのは非常に簡単です。関数filenames2index を呼び出すと、最初にテーブルにファイル名が存在するかどうかをチェックし、存在する場合はファイル名に対応する番号を返します。存在しない場合はこのテーブルを更新します。319ページでの関数filenames2indexの５行目はテーブルの更新に対応します。このテーブルでは、1つ特別なタプルがあります、それが{free, N}です。このタプルのNは、まだ割り当てられていない番号です。更新操作を行う前に、まず現在のテーブルにこの番号Nを取得します。次に、新しいファイル名をこの番号にマップし、最後に、Nの値を1増加させます。

でも、関数insertを呼び出す前に関数lookupを呼び出す2つの並列プロセスがある場合、filename2nindexによって返された結果は間違っている可能性があります。したがって、一度に1つのプロセスだけがAを呼び出すようにする必要があります。

最後に、番号に基づいてファイル名を見つけることは非常に簡単です。DETSテーブル内の対応するタプルを見つけるだけで済みます。そのようなタプルがない場合、atom error を返します。

では、節19.6に行きます。

この章では、まだ言及されていないETSおよびDETS表に対する操作がいくつかあります。
例えば、
パターンに基づいてオブジェクトの取得および削除。
ETSテーブルとDETSテーブル間、およびETSテーブルとディッシュファイル間の変換。
テーブルのリソース使用量を見つける。
テーブル内のすべての要素をトラバースする
壊れたDETSテーブルの修復
テーブルを視覚化する

これらに内容はErlangの公式ウェブサイトにありますので、この部分を跳ばします。

この章で説明するETSとDETSは、比較的単純な構造のデータを格納するために一般的に使用されます。複雑なデータを保存したい場合は、20章で説明するデータベースMnesiaを使用する方がいいです。

では、２０章に行きます。

２０章はErlangのデータベースMnesiaを紹介します。MnesiaはErlangで実装されるのデータベースである。そして、Mnesiaは独自のクエリ言語を持っています。

では、２０.1に入ります。

データベースを操作する前には、Mnesiaデータベースを作成しなければならない。ですから、323ページの下のコードを実行します。コードの２行目の関数create_schema([node()])は、現在のノードでMnesiaデータベースを初期化します。したがって、この関数を実行すると、 Mnesia.nonode@nohostという名前のフォルダがカレントディレクトリに生成されます。次に、erlangシステムを終了し、lsを使ってフォルダが存在することを確認します。

また、erlangを起動するときに324ページの例のようなパラメータを追加することもできるので、データベースの作成時に取得するフォルダ名が異なります。

では、２０.2に行きます。

このセクションでは、Mnesiaデータベースを照会する方法について説明します。Mnesiaデータベースで使用されるクエリ言語は、SQL および List comprehension に非常によく似ています。今まではデータベースにデータを書き込む方法がわからないため、すでにデータベースにはページ３２５の上の2つのテーブルがあると仮定します。Mnesiaデータベース内のすべての行はErlang Recordです。したがって、ページ３２５の表8と表9の2つのレコードも定義する必要があります。最後に、325ページの真ん中の関数do_this_onceを実行します。この関数には、前述の操作などが含まれます。ページ３２５の真ん中のような結果を見た後、データベースがセットアップされています。次に、データベースのクエリを開始できます。

最初の例はあるテーブル内のすべてのデータを照会します。関数demo(select_shop)を使用して、表shopのすべてのデータを出力します。コードはページ３２５の一番下にあります。このコードの最も重要な部分は関数qlc:qです。この関数は、データベースで使用するためにクエリを別の形式に変換します。次に、変換の結果を関数Aに渡します。関数doは、著者によって定義され、クエリを実行して結果を返すために使用されます。

クエリを実行する前に、データベースを起動してテーブル定義を読み込む必要があります。したがって、関数startとreset_tableを実行した後、さっき実装した関数demo(select_shop)を使うことができます。最後に、関数qlc:cの引数は必ずlist comprehensionです。この例での引数の意味はshopテーブルから取得されるの要素のリスト。

次の例は、shopテーブルのいくつかの列を選択します。今回関数qlc:cの引数は[{X#shop.item, X#shop.quantity} || X <- mnesia:table(shop)]になります。これまで述べたように、テーブルの各行はRecordです。したがって、ある列を取得したい場合は、各行の同じ位置の要素を取得するだけです。

次の例は、与えられた条件に基づいてテーブルからデータを選択します。たとえば、shopテーブル内のquantityが250を超えるすべての要素を選択します。今回、関数qlc:cの引数は[X#shop.item || X <- mnesia:table(shop), X#shop.quantity < 250]　になります。後ろのコンマは、かつの意味です。したがって、この引数の意味は　shop表の各行について、もしこの行のquantity要素は250を超えている、この行のitem要素の値の返します。

最後の例は、2つのテーブルの内容に基づいてデータを選択します。例えれば、quantityが250を超えて　かつ　costが　２.0よりも小さいのitemを選択したい。この場合のクエリはページ328あります。前の例と比べて、違うのは後ろぼ条件部分だけです。この条件の意味は、　shop表の各行について　もしこの行のquantity要素は250を超えている　かつ　cost表　name　＝　item　かつpriceが２.0よりも小さいのような行が存在すれば、この行のitemを返します。この条件を満たすのは、appleだけです。実行結果も同じです。

